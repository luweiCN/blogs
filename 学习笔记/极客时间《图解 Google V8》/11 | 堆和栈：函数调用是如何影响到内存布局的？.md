## 11 | 堆和栈：函数调用是如何影响到内存布局的？
### 三段代码的执行
#### 代码
1. 第一段代码
```javascript
function foo() {
 foo() // 是否存在堆栈溢出错误?
}
foo()
```
2. 第二段代码
```javascript
function foo() {
  setTimeout(foo, 0) // 是否存在堆栈溢出错误?
}
foo()
```
3.第三段代码
```javascript
function foo() {
    return Promise.resolve().then(foo)
}
foo()
```

#### 执行结果
1. 第一段造成栈溢出的错误，因为第一段代码是在同一个任务中重复调用嵌套的 foo 函数；
2. 第二段能够正确执行，因为第二段代码是使用 setTimeout 让 foo 函数在不同的任事件轮训中执行；
3. 第三段没有栈溢出的错误，却会造成页面的卡死，因为第三段代码是在同一个事件轮训中执行 foo 函数，但是却不是嵌套执行。

### 为什么使用栈结构来管理函数调用？
大部分高级语言都不约而同地采用栈这种结构来管理函数调用，为什么呢？这与函数的特性有关。通常函数有两个主要的特性：
1. **函数可以被函数调用**，可以在一个函数中调用另外一个函数，当函数调用发生时，执行代码的控制权将从父函数转移到子函数，子函数执行结束之后，又会将代码执行控制权返还给父函数；
2. **函数具有作用域机制**，所谓作用域机制，是指函数在执行的时候可以将定义在函数内部的变量和外部环境隔离，在函数内部定义的变量我们也称为**临时变量**，临时变量只能在该函数中被访问，外部函数通常无权访问，当函数执行结束之后，存放在内存中的临时变量也随之被销毁。

#### 函数可以被函数调用
```C
int getZ()
{
    return 4;
}
int add(int x, int y)
{
    int z = getZ();
    return x + y + z;
}
int main()
{
    int x = 5;
    int y = 6;
    int ret = add(x, y);
}
```
具体的函数调用示意图如下：
![](http://image.beyi.wang/fpweq.jpg)
通过上述分析，我们可以得出，**函数调用者的生命周期总是长于被调用者（后进），并且被调用者的生命周期总是先于调用者的生命周期结束 (先出)**。

#### 函数具有作用域机制
作用域机制通常表现在函数执行时，会在内存中分配函数内部的变量、上下文等数据，在函数执行完成之后，这些内部数据会被销毁掉。**所以站在函数资源分配和回收角度来看，被调用函数的资源分配总是晚于调用函数 (后进)，而函数资源的释放则总是先于调用函数 (先出)**。如下图所示：
![](http://image.beyi.wang/qnxc1.jpg)

> 所以不管从函数的生命周期或者函数的资源分配来看，它们都符合 **后进先出 (LIFO)** 的策略，而栈结构正好满足这种后进先出 (LIFO) 的需求，所以我们选择栈来管理函数调用关系是一种很自然的选择。


#### 栈如何管理函数调用？
我们通过一个例子来看函数调用过程中栈内存的变化：
```C
int add(num1,num2){
    int x2 = num1;
    int y2 = num2;
    int ret = x2 + y2;
    return ret;
}

int main()
{
    int a = 5;
    int b = 6;
    int c = add(a,b);
    return c;
}
```
下面就来分析一下这段代码执行时内存中栈的变化；
##### 1. 当运行完`int b = 6`时内存分布应该如下图所示：
![](http://image.beyi.wang/1tari.png)
图中用到了两个CPU寄存器，其中esp寄存器始终指向当前栈的栈顶，而ebp寄存器指向的是当前函数的起始位置，函数的起始位置又叫做函数的栈帧指针；因为程序当前正在指向main函数，所以ebp寄存器指向的是main函数的起始位置`10000f91`。

##### 2. 接下来程序进入`add`函数
程序进入add函数之前会做这么几件事：
1. 把当前函数（父函数）的栈帧指针入栈
2. esp指针+1，因为要让esp寄存器始终指向栈顶
这时内存分布如下图：
![](http://image.beyi.wang/31n8b.png)
程序进入add函数之后会：
1. 将x2入栈，这时候x2的位置就是add函数的栈帧指针，当前执行函数已经变成add了，所以要把ebp寄存器的值修改为add的栈帧指针
2. 执行完`int ret = x2 + y2`之后内存分布应该如下图所示：
![](http://image.beyi.wang/keucs.png)

##### 3. 接下来程序退出`add`函数，并且回复main函数的运行环境
1. add函数此时已经运行完了，需要销毁为add函数中的局部变量分配的空间，那么其实就是数据一个个的出栈就可以，但是出栈几个数据呢。CPU怎么知道你为add函数分配了几个变量呢？这时候ebp寄存器的作用就凸显出来了，esp的作用也可以提现；ebp的作用是存储当前函数的栈帧指针，那么此时ebp寄存器存储的是add函数的起始位置，我们只需要将ebp寄存器的值-1写入到esp寄存器就可以瞬间将栈恢复到执行add函数时的位置。
2. 我们的目的是要恢复main函数移交执行权时的环境，也就是ebp需要指向main函数的栈帧指针，esp需要指向栈顶；还记得第2步我们在进入add函数之前的一个操作吗？我们把当前函数的栈帧指针入栈了，也就是说这时候只需要执行一次出栈操作，把出栈的数据赋值给ebp寄存器就实现了恢复ebp重新指向main函数的栈帧指针。
3. 这时候执行`int c = add(a,b)`语句的时候`add(a,b)`的值已经有结果了，那么运行完之后的内存分布就如下图所示：
![](http://image.beyi.wang/6wod8.png)

好了，我们现在理解了栈是怎么管理函数调用的了，使用栈有非常多的优势：
1. 栈的结构和非常适合函数调用过程。
2. 在栈上分配资源和销毁资源的速度非常快，这主要归结于栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了。

### 既然有了栈，为什么还要堆？
虽然栈操作速度非常快，但是栈也是有缺点的，其中最大的缺点也是它的优点所造成的，那就是栈是连续的，所以要想在内存中分配一块连续的大空间是非常难的，因此栈空间是有限的。
因为栈空间是有限的，这就导致我们在编写程序的时候，经常一不小心就会导致栈溢出，比如函数循环嵌套层次太多，或者在栈上分配的数据过大，都会导致栈溢出，基于栈不方便存放大的数据，因此我们使用了另外一种数据结构用来保存一些大数据，这就是堆。
和栈空间不同，存放在堆空间中的数据是不要求连续存放的，从堆上分配内存块没有固定模式的，你可以在任何时候分配和释放它，而很多高级语言都使用了自动垃圾回收策略，可以实现垃圾自动回收，但是事情总有两面性，垃圾自动回收也会给我们带来一些性能问题。所以不管是自动垃圾回收策略，还是手动垃圾回收策略，要想写出高效的代码，我们都需要了解内存的底层工作机制。