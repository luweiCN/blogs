# Taro.request实现请求队列源码分析

## 背景：

1. 小程序最初为了保证性能和用户体验会限制并发请求数，最早的时候并发请求数限制为5个，当并发请求超过5个时会直接失败抛出异常。
2. 后来随着小程序的功能越来越强大微信把并发请求数改成了10个，随着小程序的复杂度越来越高，并发10个请求在一些小程序里也不够用。
3. 微信一方面需要对小程序运行时的性能消耗做一定的限制，另一方面又要满足小程序本身的需求，所以微信把底层的wx.request改成了请求队列。也就是说最大并发请求仍然是10个，但是超过10个的请求不会直接失败，而是添加到请求队列中等待，等并发请求数少于10的时候，再去从队列中取出等待的请求来执行。
4. 这么看来似乎皆大欢喜了，但是实际生产环境却不是这样，因为一部分用户的微信版本是比较低的，这样在他们的微信基础库上可能并发请求的限制还是10个甚至是5个。这就导致了开发者在发请求时还是要控制自己的请求并发数，为了使所有用户都能正常使用小程序，还必须做到最低兼容，也就是说要控制并发请求为5个。
5. Taro作为一个框架肯定要对wx.request做封装才能满足开发者的需求，下面我们就主要看看Taro是怎么实现请求队列这个功能的  

## 分析

其实请求队列实现起来难度不大，根据我们的需求来分析：

- 我们要保证并发请求是5个那么我们肯定需要用一个队列去管理这个请求队列；
- 当调用request时不是立刻发请求，而是把请求添加到请求队列，然后去检查请求队列的长度；
  - 如果此时请求队列的长度超过5，那就什么都不做
  - 但是如果现在请求队列的长度小于5，就从请求队列中取出最早加入队列的请求发送请求，并且在这个请求完成的时候(执行`complete`的时候)再从请求队列取出下一个最早添加的请求去执行

其实原理很简单，实现起来也不难，下面我贴出来Taro的实现，再关键步骤添加一些注释：

```javascript
// Taro是使用全局变量来实现请求队列的
const RequestQueue = {
  MAX_REQUEST: 5, // 最大并发请求数
  queue: [], // 请求队列
  request(options) {
    // 这个request方法就是暴露给用户使用的
    // 当调用这个request时，会先把这个请求的参数添加到请求队列，然后执行run()函数并返回run函数的执行结果
    this.push(options);
    // 返回request task
    return this.run();
  },

  push(options) {
    this.queue.push(options);
  },

  run() {
    if (!this.queue.length) {
      return;
    }
    if (this.queue.length <= this.MAX_REQUEST) {
      // 这里检查请求队列的长度是不是小于最大并发数，这个if没有else，也就是说队列长度大于最大并发数的时候什么都不做
      
      // 当请求小于最大并发数时，取出最早加入请求队列的请求
      let options = this.queue.shift();
      
      // 这里把原始的complete缓存下来，这个complete用的时候大概率会不传，而是使用promise的finally来代替，
      // 这个也是为了兼容一些习惯用原生小程序的开发者的写法
      let completeFn = options.complete;
      options.complete = (...args) => {
        // 这个complete是经过修改之后直接传给wx.request的
        // 在这里递归调用run函数自身就可以让这个队列正常执行下去
        completeFn && completeFn.apply(options, args);
        this.run();
      };
      return wx.request(options);
    }
  },
};
```

## 总结

上周我们小程序遇到的问题是在一些安卓机型的最新版微信（7.0.15）中请求一直不成功也不失败，就导致loading一直在界面上显示而影响到用户操作。通过调试发现wx.request一直不调用success、fail和complete回调，甚至设置了timeout也没有用。最终直到出现问题的几部手机无法复现也还是定位不到问题。但是在这个过程中看了Taro的request封装源码，上面只讨论了请求队列的实现。Taro还给request实现了拦截器已经取消请求等功能，之后再整体看看其他功能的实现原理。